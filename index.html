<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Golf Hero</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100vh; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="score">Coups: 0</div>
    <div id="controls">
        <button id="hit">Frapper la balle</button>
        <p>Glissez pour viser (ou utilisez la souris)</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // Initialisation de la scène
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Initialisation de la physique
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);

        // Sol
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const groundBody = new CANNON.Body({
            mass: 0,
            shape: new CANNON.Plane()
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        // Balle
        const ballGeometry = new THREE.SphereGeometry(0.2, 32, 32);
        const ballMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.y = 0.2;
        scene.add(ball);

        const ballBody = new CANNON.Body({
            mass: 1,
            shape: new CANNON.Sphere(0.2)
        });
        ballBody.position.set(0, 0.2, 0);
        world.addBody(ballBody);

        // Trou (avec physique)
        const holeGeometry = new THREE.CircleGeometry(0.3, 32);
        const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const hole = new THREE.Mesh(holeGeometry, holeMaterial);
        hole.rotation.x = -Math.PI / 2;
        hole.position.set(5, 0.01, 5);
        scene.add(hole);

        const holeBody = new CANNON.Body({
            mass: 0,
            shape: new CANNON.Cylinder(0.3, 0.3, 0.1, 32),
            position: new CANNON.Vec3(5, -0.05, 5)
        });
        world.addBody(holeBody);

        // Gestion des coups
        let strokeCount = 0;
        const scoreDisplay = document.getElementById('score');

        // Contrôles
        let isDragging = false;
        let startPoint = { x: 0, y: 0 };
        let endPoint = { x: 0, y: 0 };

        function onStart(event) {
            isDragging = true;
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            startPoint = { x: clientX, y: clientY };
        }

        function onMove(event) {
            if (!isDragging) return;
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            endPoint = { x: clientX, y: clientY };
        }

        function onEnd() {
            if (isDragging) {
                hitBall();
                strokeCount++;
                scoreDisplay.textContent = `Coups: ${strokeCount}`;
            }
            isDragging = false;
        }

        function hitBall() {
            const force = new CANNON.Vec3(
                (startPoint.x - endPoint.x) * 0.05,
                0,
                (startPoint.y - endPoint.y) * 0.05
            );
            ballBody.applyImpulse(force, ballBody.position);
        }

        document.getElementById('hit').addEventListener('click', () => {
            hitBall();
            strokeCount++;
            scoreDisplay.textContent = `Coups: ${strokeCount}`;
        });
        renderer.domElement.addEventListener('mousedown', onStart);
        renderer.domElement.addEventListener('mousemove', onMove);
        renderer.domElement.addEventListener('mouseup', onEnd);
        renderer.domElement.addEventListener('touchstart', onStart);
        renderer.domElement.addEventListener('touchmove', onMove);
        renderer.domElement.addEventListener('touchend', onEnd);

        // Gestion de la caméra
        function updateCamera() {
            const offset = new THREE.Vector3(0, 3, 3); // Position relative à la balle
            const desiredPosition = ball.position.clone().add(offset);
            
            // Interpolation douce de la position de la caméra
            camera.position.lerp(desiredPosition, 0.1);
            camera.lookAt(ball.position);
        }

        // Animation
        let gameWon = false;
        function animate() {
            requestAnimationFrame(animate);

            if (!gameWon) {
                // Mise à jour de la physique
                world.step(1/60);

                // Synchronisation des positions
                ball.position.copy(ballBody.position);
                ball.quaternion.copy(ballBody.quaternion);

                // Vérification du trou
                const distanceToHole = ballBody.position.distanceTo(holeBody.position);
                if (distanceToHole < 0.3 && ballBody.position.y < 0 && ballBody.velocity.length() < 0.1) {
                    gameWon = true;
                    ballBody.velocity.set(0, 0, 0);
                    scoreDisplay.textContent = `Victoire en ${strokeCount} coups!`;
                    setTimeout(resetGame, 2000); // Réinitialisation après 2 secondes
                }

                // Mise à jour de la caméra
                updateCamera();
            }

            renderer.render(scene, camera);
        }

        function resetGame() {
            ballBody.position.set(0, 0.2, 0);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            strokeCount = 0;
            scoreDisplay.textContent = `Coups: ${strokeCount}`;
            gameWon = false;
        }

        animate();

        // Gestion de la taille de la fenêtre
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>